import { getFirstCoord } from '../../common';
import { GeoJsonFeature, HandlerReturnWithBBox, Tags } from '../../types';
import { calcBBox } from './calcBBox';
import { MAX_ITEMS_PER_DATASET } from './const';

export function splitUntilSmallEnough(
  name: string,
  instructions: string | undefined,
  changesetTags: Tags | undefined,
  features: GeoJsonFeature[],
  depth = 0,
): HandlerReturnWithBBox {
  if (!features.length) return {};

  const bbox = calcBBox(features);

  const recursionLimit = depth > 10;
  if (recursionLimit) {
    console.log(`(!) Couldn't split ${name} (${features.length} left)`);
  }

  if (features.length <= MAX_ITEMS_PER_DATASET || recursionLimit) {
    // yay, it's small enough
    return { [name]: { features, bbox, instructions, changesetTags } };
  }

  // it's not small enough
  const tallerThanWide = bbox.maxLat - bbox.minLat > bbox.maxLng - bbox.minLng;
  if (tallerThanWide) {
    const midway = bbox.minLat + (bbox.maxLat - bbox.minLat) / 2;
    const out: [north: GeoJsonFeature[], south: GeoJsonFeature[]] = [[], []];
    for (const f of features) {
      out[+(getFirstCoord(f.geometry)[1] < midway)].push(f);
    }

    const [north, south] = out;

    return {
      ...splitUntilSmallEnough(
        `${name}^N`,
        instructions,
        changesetTags,
        north,
        depth + 1,
      ),
      ...splitUntilSmallEnough(
        `${name}^S`,
        instructions,
        changesetTags,
        south,
        depth + 1,
      ),
    };
  }

  // else: it's wider than it is tall
  const midway = bbox.minLng + (bbox.maxLng - bbox.minLng) / 2;
  const out: [east: GeoJsonFeature[], west: GeoJsonFeature[]] = [[], []];
  for (const f of features) {
    out[+(getFirstCoord(f.geometry)[0] < midway)].push(f);
  }

  const [east, west] = out;

  return {
    ...splitUntilSmallEnough(
      `${name}^E`,
      instructions,
      changesetTags,
      east,
      depth + 1,
    ),
    ...splitUntilSmallEnough(
      `${name}^W`,
      instructions,
      changesetTags,
      west,
      depth + 1,
    ),
  };
}

/** normalizes the weird ^N^S^E names generated by `splitUntilSmallEnough` */
export function normalizeName(
  input: HandlerReturnWithBBox,
): HandlerReturnWithBBox {
  const index: Record<string, number> = {};
  const output: HandlerReturnWithBBox = {};

  for (const name in input) {
    const newName = name.replace(/^([^^]+)(\^\w)+$/, (_, withoutSuffix) => {
      index[withoutSuffix] ||= 0;
      index[withoutSuffix] += 1;
      return `${withoutSuffix} ${index[withoutSuffix]}`;
    });

    output[newName] = input[name];
  }
  return output;
}
